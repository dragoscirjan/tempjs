import * as fs from 'fs';

import * as os from 'os';

import * as path from 'path';

import bytes from 'bytes';

import crs from 'crypto-random-string';

import * as shortid from 'shortid';

export class FileHandle implements fs.promises.FileHandle {
  private constructor(private filename: string, private filehandle: fs.promises.FileHandle, public fd: number) {}

  public static async create(filename: string): Promise<FileHandle> {
    const filehandle = await fs.promises.open(filename, 'w+');
    const fh = new FileHandle(filename, filehandle, filehandle.fd);
    return fh;
  }

  get fileHanle(): fs.promises.FileHandle {
    return this.filehandle;
  }

  get name(): string {
    return this.filename;
  }

  appendFile(
    data: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: {encoding?: string | null; mode?: string | number; flag?: string | number} | string | null,
  ): Promise<void> {
    return this.filehandle.appendFile(data, options);
  }

  chown(uid: number, gid: number): Promise<void> {
    return this.filehandle.chown(uid, gid);
  }

  chmod(mode: string | number): Promise<void> {
    return this.filehandle.chmod(mode);
  }

  datasync(): Promise<void> {
    return this.filehandle.datasync();
  }

  sync(): Promise<void> {
    return this.filehandle.sync();
  }

  read<TBuffer extends Uint8Array>(
    buffer: TBuffer,
    offset?: number | null,
    length?: number | null,
    position?: number | null,
  ): Promise<{bytesRead: number; buffer: TBuffer}> {
    return this.filehandle.read(buffer, offset, length, position);
  }

  readFile(options?: {encoding?: null | BufferEncoding; flag?: string | number} | null): Promise<Buffer>;
  readFile(options: {encoding: BufferEncoding; flag?: string | number} | BufferEncoding): Promise<string>;
  readFile(options?: {encoding?: string | null; flag?: string | number} | string | null): Promise<string | Buffer> {
    return this.filehandle.readFile(options);
  }

  stat(): Promise<fs.Stats> {
    return this.filehandle.stat();
  }

  truncate(len?: number): Promise<void> {
    return this.filehandle.truncate(len);
  }

  utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void> {
    return this.filehandle.utimes(atime, mtime);
  }

  // write<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;
  // write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;
  write(
    data: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    ...args: any // eslint-disable-line @typescript-eslint/no-explicit-any
  ): Promise<{bytesWritten: number; buffer: string}> {
    return this.filehandle.write(data, ...args);
  }

  writeFile(
    data: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: {encoding?: string | null; mode?: string | number; flag?: string | number} | string | null,
  ): Promise<void> {
    return this.filehandle.writeFile(data, options);
  }

  writev(buffers: NodeJS.ArrayBufferView[], position?: number): Promise<fs.WriteVResult> {
    return this.writev(buffers, position);
  }

  readv(buffers: NodeJS.ArrayBufferView[], position?: number): Promise<fs.ReadVResult> {
    return this.filehandle.readv(buffers, position);
  }

  close(): Promise<void> {
    return this.filehandle.close();
  }

  // /**
  //  * Will remove the file. It's programmer's responsability to make sure file is closed.
  //  */
  // unlink(): Promise<void> {
  //   return fs.promises.unlink(this.filename);
  // }
}

export type ValidationCallback = (err: Error) => void;

export type TempFileValidationCallback = (err: Error | null, file?: FileHandle) => void;

export interface TempFileOptions {
  dir?: string;
  pattern?: string;
}

/**
 * This is a rewrite of the GoLang [os.TempFile](https://golang.org/pkg/io/ioutil/#TempFile) method, with additional
 * functionality.
 *
 * tempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the
 * resulting `FileHandle`. The filename is generated by taking pattern and adding a random string to the end. If
 * pattern includes a "*", the random string replaces the last "*". If dir is the empty string, `tempFile` uses the
 * default directory for temporary files (see `os.tmpdir()`). Multiple programs calling `tempFile` simultaneously
 * will not choose the same file. The caller can use f.name to find the pathname of the file. It is the caller's
 * responsibility to remove the file when no longer needed.
 *
 * @param {TempFileOptions} options Optional
 * @param {TempValidationCallback} callback Optional
 * @returns {Promise<TempFileInterface>|void} Returns Promise if callback is not defined, void if callback is defined.
 */
export const tempFile = (
  options?: TempFileOptions,
  callback?: TempFileValidationCallback,
): Promise<FileHandle> | void => {
  const localOptions = {
    dir: os.tmpdir(),
    pattern: '',
    ...(options || {}),
  };

  const name =
    localOptions.pattern.indexOf('*') >= 0
      ? localOptions.pattern.replace('*', shortid.generate())
      : localOptions.pattern + shortid.generate();

  const promise = FileHandle.create(path.join(localOptions.dir || __dirname, name));
  if (!callback) {
    return promise;
  }

  promise.then((fileHandler) => callback(null, fileHandler)).catch(callback);
};

export type TempFileOfSizeOptions = {
  size: string;
} & TempFileOptions;

/**
 * tempFileOfSize behaves exactly like `tempFile`, however it will write random data in the file, of a mentioned size.
 * It is developer's responsibility to make sure size input is correct. See: https://www.npmjs.com/package/bytes for
 * behavior. File's write/read cursor will be at the end of file.
 *
 * @param {TempFileOfSizeOptions} options Optional
 * @param {TempValidationCallback} callback Optional
 * @returns {Promise<TempFileInterface|void>} Returns Promise if callback is not defined, void if callback is defined.
 */
export const tempFileOfSize = (
  options: TempFileOfSizeOptions,
  callback?: TempFileValidationCallback,
): Promise<FileHandle> | void => {
  const localOptions = {
    dir: os.tmpdir(),
    pattern: '',
    ...options,
  };

  const writeOfSize = async (fhos: FileHandle): Promise<FileHandle> => {
    let size = bytes(localOptions.size);

    const chunkSize = bytes('1Mb');

    while (size > chunkSize) {
      const written = await fhos.write(crs({length: chunkSize /*, type: 'base64'*/}), 'utf-8');
      if (written.bytesWritten !== chunkSize) {
        fhos.close();
        throw new Error(
          `error writing file: tried to write ${chunkSize} bytes, but only ${written.bytesWritten} were written`,
        );
      }
      size -= chunkSize;
    }

    if (size > 0) {
      const written = await fhos.write(crs({length: size /*, type: 'base64'*/}), 'utf-8');
      if (written.bytesWritten !== size) {
        fhos.close();
        throw new Error(
          `error writing file: tried to write ${size} bytes, but only ${written.bytesWritten} were written`,
        );
      }
    }
    return fhos;
  };

  if (!callback) {
    return (tempFile(options) as Promise<FileHandle>).then(writeOfSize);
  }

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  tempFile(options, (err: Error | null, fhos?: FileHandle) => {
    if (err) return callback(err);
    writeOfSize(fhos!)
      .then((fh) => callback(null, fh))
      .catch(callback);
  });
  /* eslint-enable @typescript-eslint/no-non-null-assertion */
};

export type TempDirValidationCallback = (err: Error | null, name?: string) => void;

export type TempDirOptions = {default?: boolean} & TempFileOptions;

/**
 * This is a rewrite of the GoLang [os.TempDir](https://golang.org/pkg/io/ioutil/#TempDir) method, with additional
 * functionality.
 *
 * `tempDir` creates a new temporary directory in the directory dir. The directory name is generated by taking
 * pattern and applying a random string to the end. If pattern includes a "*", the random string replaces the last "*".
 * `tempDir` returns the name of the new directory. If dir is the empty string, `tempDir` uses the default directory for
 * temporary files (see os.tmpdir()). Multiple programs calling `tempDir` simultaneously will not choose the same
 * directory. It is the caller's responsibility to remove the directory when no longer needed.
 *
 * If `options.default` is set to `true` in the `options` argument, `tempDir` will make use of NodeJs's
 * [fs.promises.mkdtemp](https://nodejs.org/api/fs.html#fs_fs_mkdtemp_prefix_options_callback) method, giving as
 * `prefix` the `options.pattern` value (which becomes mandatory).
 *
 * @param {TempDirOptions} options optional
 * @param {TempDirValidationCallback} callback optional
 * @returns {Promise<string>|void} Returns Promise if callback is not defined, void if callback is defined.
 */
export const tempDir = (options?: TempDirOptions, callback?: TempDirValidationCallback): Promise<string> | void => {
  const localOptions = {
    default: false,
    dir: os.tmpdir(),
    pattern: '',
    ...(options || {}),
  };

  let promise: Promise<string>;
  if (!localOptions.default) {
    const name =
      localOptions.pattern.indexOf('*') >= 0
        ? localOptions.pattern.replace('*', shortid.generate())
        : localOptions.pattern + shortid.generate();
    const dirPath = path.join(localOptions.dir, name);
    promise = fs.promises
      .mkdir(dirPath, {
        recursive: true,
      })
      .then(() => dirPath);
  } else {
    if (!localOptions.pattern) {
      const err = new Error('invalid `options.pattern` value: please add pattern value');
      if (!callback) {
        throw err;
      }
      return callback(err);
    }
    promise = fs.promises.mkdtemp(path.join(localOptions.dir, localOptions.pattern));
  }

  if (!callback) {
    return promise;
  }

  promise.then((dirName) => callback(null, dirName)).catch(callback);
};

export type tempDirWithFilesOptions = {
  maxDepth?: number;
  maxSubFolders?: number;
  maxFilesPerDir?: number;
  maxFileSize?: string;
} & TempDirOptions;

// const generatePaths = (maxSubfolders: number, depth: number): string[] => {
//   if (depth === 0) {
//     return [];
//   }
//   const randSubfolders = Math.trunc(Math.random() * 1000) % maxSubfolders;
//   let dirs: string[] = [];
//   for (let i = 0; i < randSubfolders; i++) {
//     const dir = shortid.generate();
//     dirs.push(dir);
//     dirs = dirs.concat(dirs, generatePaths(maxSubfolders, depth - 1));
//   }
//   return dirs;
// };

export const tempDirWithFiles = (
  options: tempDirWithFilesOptions,
  callback?: TempDirValidationCallback,
): Promise<string> | void => {
  const localOptions = {
    maxDepth: 5,
    maxSubFolders: 5,
    maxFilesPerDir: 5,
    maxFilesSize: '10Mb',
    ...options,
  };

  // let tempDirPath = '';
  // try {
  //   tempDirPath = (await tempDir(localOptions)) as string;
  // } catch (e) {
  //   if (callback) {
  //     return callback(e);
  //   }
  //   throw e;
  // }

  // const dirs = generatePaths(localOptions.maxSubFolders, localOptions.maxDepth);

  if (!callback) {
    return;
  }

  callback(null, JSON.stringify(localOptions));
};
